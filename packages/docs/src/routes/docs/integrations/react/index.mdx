---
title: Qwik React
contributors:
  - manucorporat
  - swwind
  - reemardelarosa
  - mhevery
---
import CodeSandbox from '../../../../components/code-sandbox/index.tsx';

# Qwik React ⚛️

Qwik React allows you to use [React](https://reactjs.org/) within [Qwik](https://qwik.dev/). The advantage of using Qwik React is that you can use existing React components and libraries within Qwik. This allows you to take advantage of the large ecosystem of React components and libraries such as [Material UI](https://mui.com/), [Threejs](https://github.com/pmndrs/react-three-fiber) and [React Spring](https://react-spring.io/). It is also a good way to get the benefits of Qwik without having to rewrite your React application.

## Basic Usage

The basic usage of Qwik React is to take existing React components and wrap them in a `qwikify$` function. This function will create a Qwik component that can be used within Qwik and which will turn the React component into an island allowing you the freedom to fine-tune when the React component should hydrate.

Basic usage
```tsx
// This pragma is required so that React JSX is used instead of Qwik JSX
/** @jsxImportSource react */
import { qwikify$ } from '@builder.io/qwik-react';

// An existing React component
function Greetings() {
  return <div>Hello from React</div>;
}

// Qwik component wrapping the React component
export const QGreetings = qwikify$(Greetings);
```

## 0. Installation

Before you can use Qwik React you need to configure the Qwik project to use Qwik React. The simplest way is to run the following command:

> If you don't have a Qwik app yet, then you need to [create one first](/docs/(qwik)/getting-started/index.mdx), then, follow the instructions and run the command add React to your app.


```bash
npm run qwik add react
```


The above command will perform the following:

1. Install the required dependencies in `package.json`:
   ```json
   {
    ...,
     "dependencies": {
      ...,
       "@builder.io/qwik-react": "0.5.0",
       "@types/react": "18.0.28",
       "@types/react-dom": "18.0.11",
       "react": "18.2.0",
       "react-dom": "18.2.0",
     }
   }
   ```
   > **Note**: This is not an emulation of React. We are using the actual React library.
2. configure Vite to use the `@builder.io/qwik-react` plugin:
   ```ts
   // vite.config.ts
   import { qwikReact } from '@builder.io/qwik-react/vite';

   export default defineConfig(() => {
      return {
        ...,
        plugins: [
          ..., 
          // The important part
          qwikReact()
        ],
      };
   });
   ```

> **Note**: The `npm run qwik add react` will also configure a demo route showcasing the Qwik React integration. These are:
> - `package.json` `dependencies`:
>   - `@emotion/react 11.10.6`
>   - `@emotion/styled 11.10.6`
>   - `@mui/material 5.11.9`
>   - `@mui/x-data-grid 5.17.24`
> - `src/route`:
>   - `/src/routes/react`: New public route showcasing react integration 
>   - `/src/integrations/react`: Here's where the react component lives
>
> We will ignore these in this guide and instead take you through the process from the beginning.


## 1. Hello World

Let's start with a simple example. We will create a simple React component and then wrap it in a Qwik component. We will then use the Qwik component in a Qwik route.

<CodeSandbox src="/src/routes/demo/react/hello-world/react.tsx" style={{ height: '6em' }}>
```tsx /qwikify$/
/** @jsxImportSource react */
import { qwikify$ } from '@builder.io/qwik-react';

function Greetings() {
  return <div>Hello from React</div>;
}

export const QGreetings = qwikify$(Greetings);
```
</CodeSandbox>

The `@builder.io/qwik-react` package exports the `qwikify$()` function that lets you convert React components into Qwik components, that you can use across your application.

> **Note:** You CAN NOT use React components in Qwik without converting them first, using `qwikify$()`. Even though [React and Qwik components look similar](/docs/(qwikcity)/guides/qwik-react/index.mdx), they are fundamentally very different.

React and Qwik components can not be mixed in the same file, if you check your project right after running the installation command, you will see a new folder `src/integrations/react/`, we recommend that you place your React components there.

## 2. Hydrating react islands

The above example shows how to SSR static React content on the server. The benefit is that that component will never re-render in the browser and therefore its code never has to download. But what if the component needs to be interactive, and therefore we need to download its behavior in the browser? Let's start with building a simple counter component example in React.

<CodeSandbox src="/src/routes/demo/react/counter-simple/react.tsx" style={{ height: '6em' }}>
```tsx
/** @jsxImportSource react */
import { qwikify$ } from '@builder.io/qwik-react';

function Greetings() {
  return <div>Hello from React</div>;
}

export const QGreetings = qwikify$(Greetings);
```
</CodeSandbox>



## 3. Inter-island communication

## 4. Content projection (`children`)

## 5. `host:` Listeners

## 6. Using React libraries

# ============
```tsx title="src/integrations/react/mui.tsx"
/** @jsxImportSource react */

import { qwikify$ } from '@builder.io/qwik-react';
import { Alert, Button, Slider } from '@mui/material';
import { DataGrid, GridColDef, GridValueGetterParams } from '@mui/x-data-grid';

export const MUIButton = qwikify$(Button);
export const MUIAlert = qwikify$(Alert);
export const MUISlider = qwikify$(Slider, { eagerness: 'hover' });
```

> **Important:** You need to import `/** @jsxImportSource react */` at the top of your file, this is an instruction to the compiler to use React as the JSX factory.

In a nutshell, the rules are:

1. Don't mix React and Qwik components in the same file.
2. Place all your react code inside the `src/integrations/react` folder.
3. Add `/** @jsxImportSource react */` at the top of the files containing React code.
4. Use `qwikify$()` to convert React components into Qwik components, which you can import from Qwik modules.

Now your Qwik can import `MUIButton` and use it as any other Qwik component:

```tsx
import { component$ } from '@builder.io/qwik';
import { MUIAlert, MUIButton } from '~/integrations/react/mui';

export default component$(() => {
  return (
    <>
      <MUIButton client:hover>Hello this is a button</MUIButton>

      <MUIAlert severity="warning">This is a warning from Qwik</MUIAlert>
    </>
  );
});
```

## `qwikify$()`

The `qwikify$(ReactCmp, options?): QwikCmp` allows to implement partial hydration of React components. It works by wrapping the SSR and hydration logic of React into a Qwik component that can execute React's `renderToString()` during SSR and dynamically call `hydrateRoot()` when specified.

Notice that by default no React code will run in the browser, meaning that React component will NOT be interactive by default, for example, in the following example, we _qwikify_ the [Slider](https://mui.com/material-ui/react-slider/) component from MUI, but it will not be interactive.

```tsx
/** @jsxImportSource react */
import { qwikify$ } from '@builder.io/qwik-react';
import { Slider } from '@mui/material';
export const MUISlider = qwikify$(Slider);
```

```tsx
import { component$ } from '@builder.io/qwik';
import { MUISlider } from '~/integrations/react/mui';

export default component$(() => {
  return (
    <>
      <MUISlider></MUISlider>
    </>
  );
});
```

## Limitations

### Every qwikified react component is isolated

Each instance of a qwikified react component becomes an independent React app. Fully isolated.

```tsx
export const MUISlider = qwikify$(Slider);

<MUISlider></MUISlider>
<MUISlider></MUISlider>
```

- Each `MUISlider` is a fully isolated React application, with its own state, lifecycle, etc.
- Styles will be duplicated
- State will not be shared
- [Context](https://react.dev/learn/passing-data-deeply-with-context) will not be inherited.
- Islands will [hydrate](https://react.dev/reference/react-dom/client/hydrateRoot) independently

### By default interactivity is disabled

By default, qwikified components will not be interactive, please look at the next section to learn how to enable interactivity.

### Use `qwikify$()` as a migration strategy

Using React components in Qwik is a great way to migrate your application to Qwik, but it's not a silver bullet, you will need to rewrite your components to take advantage of Qwik's features.

It's also a great way to enjoy the React ecosystem, like [threejs](https://github.com/pmndrs/react-three-fiber) or [data-grid libs](https://mui.com/x/react-data-grid/).

> Dont abuse of `qwikify$()` to build your own application, all performance gains will be lost.

### Build wide islands, not leaf nodes

For example, if you need to use several MUI components, to build a list, dont qwikify each individual MUI component, instead, build the whole list as a single qwikified React component.

#### GOOD: Wide island

A single qwikified component, with all the MUI components inside. Styles will not be duplicated, and context and theming will work as expected.

```tsx
import * as React from 'react';
import List from '@mui/material/List';
import ListItem from '@mui/material/ListItem';
import ListItemText from '@mui/material/ListItemText';
import ListItemAvatar from '@mui/material/ListItemAvatar';
import Avatar from '@mui/material/Avatar';
import ImageIcon from '@mui/icons-material/Image';
import WorkIcon from '@mui/icons-material/Work';
import BeachAccessIcon from '@mui/icons-material/BeachAccess';

// Qwikify the whole list
export const FolderList = qwikify$(() => {
  return (
    <List sx={{ width: '100%', maxWidth: 360, bgcolor: 'background.paper' }}>
      <ListItem>
        <ListItemAvatar>
          <Avatar>
            <ImageIcon />
          </Avatar>
        </ListItemAvatar>
        <ListItemText primary="Photos" secondary="Jan 9, 2014" />
      </ListItem>
      <ListItem>
        <ListItemAvatar>
          <Avatar>
            <WorkIcon />
          </Avatar>
        </ListItemAvatar>
        <ListItemText primary="Work" secondary="Jan 7, 2014" />
      </ListItem>
      <ListItem>
        <ListItemAvatar>
          <Avatar>
            <BeachAccessIcon />
          </Avatar>
        </ListItemAvatar>
        <ListItemText primary="Vacation" secondary="July 20, 2014" />
      </ListItem>
    </List>
  );
});
```

#### BAD: Leaf nodes

Leaf nodes are qwikified independently, effectively rendering dozens of nested react applications, each fully isolated from the others, and styles being duplicated.

```tsx
import * as React from 'react';
import List from '@mui/material/List';
import ListItem from '@mui/material/ListItem';
import ListItemText from '@mui/material/ListItemText';
import ListItemAvatar from '@mui/material/ListItemAvatar';
import Avatar from '@mui/material/Avatar';
import ImageIcon from '@mui/icons-material/Image';
import WorkIcon from '@mui/icons-material/Work';
import BeachAccessIcon from '@mui/icons-material/BeachAccess';

export const MUIList = qwikify$(List);
export const MUIListItem = qwikify$(ListItem);
export const MUIListItemText = qwikify$(ListItemText);
export const MUIListItemAvatar = qwikify$(ListItemAvatar);
export const MUIAvatar = qwikify$(Avatar);
export const MUIImageIcon = qwikify$(ImageIcon);
export const MUIWorkIcon = qwikify$(WorkIcon);
export const MUIBeachAccessIcon = qwikify$(BeachAccessIcon);
```

```tsx
// Qwik component using dozens of nested React islands
// Each MUI-* it's an independent React application
export const FolderList = component$(() => {
  return (
    <MUIList sx={{ width: '100%', maxWidth: 360, bgcolor: 'background.paper' }}>
      <MUIListItem>
        <MUIListItemAvatar>
          <MUIAvatar>
            <MUIImageIcon />
          </MUIAvatar>
        </MUIListItemAvatar>
        <MUIListItemText primary="Photos" secondary="Jan 9, 2014" />
      </MUIListItem>
      <MUIListItem>
        <MUIListItemAvatar>
          <MUIAvatar>
            <MUIWorkIcon />
          </MUIAvatar>
        </MUIListItemAvatar>
        <MUIListItemText primary="Work" secondary="Jan 7, 2014" />
      </MUIListItem>
      <MUIListItem>
        <MUIListItemAvatar>
          <MUIAvatar>
            <MUIBeachAccessIcon />
          </MUIAvatar>
        </MUIListItemAvatar>
        <MUIListItemText primary="Vacation" secondary="July 20, 2014" />
      </MUIListItem>
    </MUIList>
  );
});
```

## Adding interactivity

In order to add interactivity, in React terminology we need to [hydrate](https://react.dev/reference/react-dom/hydrate), usually in React applications this hydration task happens unconditionally at load time, [adding a massive overhead](https://www.builder.io/blog/hydration-is-pure-overhead) and making sites slow.

Qwik allows you decide when to hydrate your components, by using the `client:` JSX properties, this technique is commonly called partial hydration, popularized by [Astro](https://astro.build/).

```diff
export default component$(() => {
  return (
    <>
-      <MUISlider></MUISlider>
+      <MUISlider client:visible></MUISlider>
    </>
  );
});
```

Qwik comes with different strategies out of the box:

### `client:load`

The component eagerly hydrates when the document loads.

```tsx
<MUISlider client:load></MUISlider>
```

**Use case:** Immediately-visible UI elements that need to be interactive as soon as possible.

### `client:idle`

The component eagerly hydrates when the browser first become idle, ie, when everything important as already run before.

```tsx
<MUISlider client:idle></MUISlider>
```

**Use case:** Lower-priority UI elements that don’t need to be immediately interactive.

### `client:visible`

The component eagerly hydrates when it becomes visible in the viewport.

```tsx
<MUISlider client:visible></MUISlider>
```

**Use case:** Low-priority UI elements that are either far down the page (“below the fold”) or so resource-intensive to load that you would prefer not to load them at all if the user never saw the element.

### `client:hover`

The component eagerly hydrates when the mouse is over the component.

```tsx
<MUISlider client:hover></MUISlider>
```

**Use case:** Lowest-priority UI elements which interactivity is not crucial, and only needs to run in desktop.

### `client:signal`

This is an advanced API that allows to hydrate the component whenever the passed signal becomes `true`.

```tsx
export default component$(() => {
  const hydrateReact = useSignal(false);
  return (
    <>
      <button onClick$={() => (hydrateReact.value = true)}>Hydrate Slider when click</button>

      <MUISlider client:signal={hydrateReact}></MUISlider>
    </>
  );
});
```

This effectively allows you to implement custom strategies for hydration.

### `client:event`

The component eagerly hydrates when specified DOM events are dispatched.

```tsx
<MUISlider client:event="click"></MUISlider>
```

### `client:only`

When `true`, the component will not run in SSR, only in the browser.

```tsx
<MUISlider client:only></MUISlider>
```

## Listening to React events

Events in React are handled by passing a function as a property to the component, for example:

```tsx
// React code (won't work in Qwik)

import { Slider } from '@mui/material';

<Slider onChange={() => console.log('value changed')}></Slider>;
```

The `qwikify()` function will convert this into a Qwik component that will also expose the React events as Qwik [QRLs](/docs/(qwik)/advanced/qrl/index.mdx):

```tsx
import { Slider } from '@mui/material';
import { qwikify$ } from '@builder.io/qwik-react';
const MUISlider = qwikify$(Slider);

<MUISlider client:visible onChange$={() => console.log('value changed')} />;
```

> Notice that we use the `client:visible` property to eagerly hydrate the component, otherwise the component would not be interactive and the events would never be dispatched.

## Host element

When wrapping a React component with `qwikify$()`, under the hood, a new DOM element is created, such as:

```html
<qwik-react>
  <button class="MUI-button"></button>
</qwik-react>
```

> Notice, that the tag name of the wrapper element is configurable via `tagName`: `qwikify$(ReactCmp, { tagName: 'my-react' })`.

### Listen to DOM events without hydration

The host element is not part of React, meaning that hydration is not necessary to listen for events, in order to add custom attributes and events to the host element, you can use the `host:` prefix in the JSX properties, such as:

```tsx
<MUIButton
  host:onClick$={() => {
    console.log('click a react component without hydration!!');
  }}
/>
```

This will effectively allow you to respond to a click in a [MUI button](https://mui.com/material-ui/react-button/) without downloading a single byte of React code.

🧑‍💻Happy hacking!
