---
title: Getting Started
contributors:
  - manucorporat
  - jesperp
  - adamdbradley
  - steve8708
  - cunzaizhuyi
  - mousaAM
  - zanettin
  - Craiqser
  - MyltsinVV
  - literalpie
  - colynyu
  - the-r3aper7
  - ahmadalfy
  - renomureza
  - mhevery
---

import CodeSandbox from '../../../../components/code-sandbox/index.tsx';

# Getting Started Qwikly

Qwik is a new kind of framework that is [resumable](../concepts/resumable/index.mdx) (no eager JS execution and no hydration), built for the edge and [familiar to the React developers](/docs/guides/qwik-react/).

If you want to play with it right away, try our in-browser playgrounds:

- [StackBlitz Qwik](https://qwik.new) (Full Qwik + Qwikcity integration)
- [Examples playground](/examples/reactivity/counter/) (Qwik only (no routing))

## Prerequisites

If you want to get started with Qwik locally, you will need the following:

- [Node.js v16.8](https://nodejs.org/en/download/) or higher
- Your favorite IDE ([vscode](https://code.visualstudio.com/) recommended)
- Optionally you may want to read [think qwik](../think-qwik/index.mdx)

## Create an app using the CLI

The first step is to create a Qwik application with our CLI. The CLI will create a blank starter so that you can quickly familiarize yourself with it. Qwik supports NPM, yarn and pnpm.

Run the Qwik CLI in your shell. Choose the package manager you prefer and run one of the following commands:

```shell
npm create qwik@latest
pnpm create qwik@latest
yarn create qwik
```

The CLI will guide you through an interactive menu to set the project-name, select one of the starters and asks if you want to install the dependencies. To find out more about the files generated by reading up on the [project structure](/docs/project-structure/).

Start the development server

```shell
npm start
pnpm start
yarn start
```

## Qwik Hello World

To get you familiar with Qwik we have created a very simple "Hello World" application tutorial that touches on the most important concepts of Qwik. For each part we touch on we will link you to the relevant documentation where you can find out more about the given concept.

We will use https://icanhazdadjoke.com as our API to get a random joke. We will create a simple application that will display a random joke and a button to get a new joke.


## 1. Create A Route

Everything starts by serving a page at a particular route. So let's build a simple app that serves a random dad joke application on `/joke/` route. Qwikcity (Qwik's meta-framework) uses [directory-based](/docs/routing/) routing. To get started:

1. Create a new `index.tsx` file in the `src/routes/joke/` directory in your project. (You will need to create the `joke` directory first.)
2. Each route's `index.tsx` file must have an `export default component$(...)` so that Qwikcity knows what content to serve. Paste the following content to `src/routes/joke/index.tsx`:

```tsx
import { component$ } from '@builder.io/qwik';

export default component$(() => {
  return <div class="section bright">A Joke!</div>;
});
```

3. Navigate to `http://127.0.0.1:5173/joke/` to see your new page working.

> NOTE:
>
> - Your `joke` route default component is surrounded by an existing layout. See [Layout](/docs/layout/) for more details on what layouts are and how to work with them.
> - For more details about how to author components see the [Component API](/docs/(qwik)/components/overview/index.mdx) section.

<CodeSandbox src="/src/routes/demo/getting-started/01-route/index.tsx" style={{ height: '6em' }}>
```tsx
import { component$ } from '@builder.io/qwik';

export default component$(() => {
  return <div class="section bright">A Joke!</div>;
});
```
</CodeSandbox>

## 2. Loading Data

A common thing a page does is load data to display to the user. This is performed using [route loaders](/docs/route-loader/).

1. Open `src/routes/joke/index.tsx` and add this code:

```tsx
import { routeLoader$ } from '@builder.io/qwik-city';

export const useDadJoke = routeLoader$(async () => {
  const response = await fetch('https://icanhazdadjoke.com/', {
    headers: { Accept: 'application/json' },
  });
  return response.json();
});
```

2. Then add the `useDadJoke()` hook to the `default` component and use the result in the JSX:

```tsx
export default component$(() => {
  const dadJokeSignal = useDadJoke();
  return (
    <div class="section bright">
      <div>{dadJokeSignal.value.joke}</div>
    </div>
  );
});
```

3. Navigate to `http://127.0.0.1:5173/` to see the application running.

What does the above code do?

- The function passed to `routeLoader$` is invoked on the server eagerly before any component is rendered and is responsible for loading data.
- The `routeLoader$` returns a use-hook (`useDadJoke`) that can be used in the component to retrieve the server data.

> **NOTE**
>
> - The `routeLoader$` is invoked eagerly on the server before any component is rendered, even if its use-hook is not invoked in any component.
> - The `routeLoader$` return type is inferred in the component without the need for any additional type information.

<CodeSandbox src="/src/routes/demo/getting-started/02-loading-data/index.tsx" style={{ height: '6em' }}>
```tsx
import { component$ } from '@builder.io/qwik';
import { routeLoader$ } from '@builder.io/qwik-city';

export const useDadJoke = routeLoader$(async () => {
  const response = await fetch('https://icanhazdadjoke.com/', {
    headers: { Accept: 'application/json' },
  });
  return (await response.json()) as {
    id: string;
    status: number;
    joke: string;
  };
});

export default component$(() => {
  const dadJokeSignal = useDadJoke();
  return (
    <div class="section bright">
      <div>{dadJokeSignal.value.joke}</div>
    </div>
  );
});
```
</CodeSandbox>

## 3. Posting Data to Server

Previously we used `routeLoader$` to send data from the server to the client. We use [`routeAction$`](/docs/action/) to post (send) data from the client back to the server.

NOTE: `routeAction$` is the preferred way to send data to the server because it uses the browser native form API which works even if JavaScript is disabled.

To declare an action:

1. Open `src/routes/joke/index.tsx` and add this code:


```tsx
import { routeAction$, Form } from '@builder.io/qwik-city';

export const useJokeVoteAction = routeAction$((props) => {
  // Leave it as an exercise for the reader to implement this.
  console.log('VOTE', props);
});
```

2. Update the `export default` component to use the `useJokeVoteAction` hook. This is done by adding the `<Form>`.

```tsx
export default component$(() => {
  const dadJokeSignal = useDadJoke();
  const favoriteJokeAction = useJokeVoteAction();
  return (
    <div class="section bright">
      <div>{dadJokeSignal.value.joke}</div>
      <Form action={favoriteJokeAction}>
        <input type="hidden" name="jokeID" value={dadJokeSignal.value.id} />
        <button name="vote" value="up">
          üëç
        </button>
        <button name="vote" value="down">
          üëé
        </button>
      </Form>
    </div>
  );
});
```

3. Navigate to `http://127.0.0.1:5173/` to see the application running.

What does the above code do?

- `routeAction$` is used to receive data.
  - The function passed to `routeAction$` is invoked on the server whenever the form is posted.
  - The `routeAction$` returns a use-hook (`useJokeVoteAction`) that can be used in the component post the form data.
- `Form` is a convenience component that wraps the browser's native `<form>` element.

Things to note:

- For validation see [zod validation](/docs/action/#zod-validation).
- The `routeAction$` works even if JavaScript is disabled.
- If JavaScript is enabled the `Form` component will prevent the browser from posting the form and instead post the data using JavaScript and emulate the browser's native form behavior without full refresh.

<CodeSandbox src="/src/routes/demo/getting-started/03-posting-data/index.tsx" style={{ height: '8em' }}>
```tsx
/* eslint-disable no-console */
import { component$ } from '@builder.io/qwik';
import { routeLoader$, Form, routeAction$ } from '@builder.io/qwik-city';

export const useDadJoke = routeLoader$(async () => {
  const response = await fetch('https://icanhazdadjoke.com/', {
    headers: { Accept: 'application/json' },
  });
  return (await response.json()) as {
    id: string;
    status: number;
    joke: string;
  };
});

export const useJokeVoteAction = routeAction$((props) => {
  console.log('VOTE', props);
});

export default component$(() => {
  const dadJokeSignal = useDadJoke();
  const favoriteJokeAction = useJokeVoteAction();
  return (
    <div class="section bright">
      <div>{dadJokeSignal.value.joke}</div>
      <Form action={favoriteJokeAction}>
        <input type="hidden" name="jokeID" value={dadJokeSignal.value.id} />
        <button name="vote" value="up">
          üëç
        </button>
        <button name="vote" value="down">
          üëé
        </button>
      </Form>
    </div>
  );
});
```
</CodeSandbox>

## 4. Modifying State

Keeping track of the state and updating UI is core to what applications do. Qwik provides a `useSignal` hook to keep track of the application's state. To learn more see [state management](/docs/components/state/).

To declare state:

1. Declare the component's state using `useSignal()`.
   ```tsx
   const isFavoriteSignal = useSignal(false);
   ```
2. Add a button to the component that will modify the state.
   ```tsx
   <button onClick$={() => (isFavoriteSignal.value = !isFavoriteSignal.value)}>
     {isFavoriteSignal.value ? '‚ù§Ô∏è' : 'ü§ç'}
   </button>
   ```

NOTE:

- Clicking on the button will update the state and the UI will be updated.

<CodeSandbox src="/src/routes/demo/getting-started/04-state/index.tsx" style={{ height: '10em' }}>
```tsx
/* eslint-disable no-console */
import { component$, useSignal, useTask$ } from '@builder.io/qwik';
import {
  routeLoader$,
  Form,
  routeAction$,
  server$,
} from '@builder.io/qwik-city';

export const useDadJoke = routeLoader$(async () => {
  const response = await fetch('https://icanhazdadjoke.com/', {
    headers: { Accept: 'application/json' },
  });
  return (await response.json()) as {
    id: string;
    status: number;
    joke: string;
  };
});

export const useJokeVoteAction = routeAction$((props) => {
  console.log('VOTE', props);
});

export default component$(() => {
  const isFavoriteSignal = useSignal(false);
  const dadJokeSignal = useDadJoke();
  const favoriteJokeAction = useJokeVoteAction();
  useTask$(({ track }) => {
    track(()=> isFavoriteSignal.value);
    console.log('FAVORITE (isomorphic)', isFavoriteSignal.value);
    server$(() => {
      console.log('FAVORITE (server)', isFavoriteSignal.value);
    })();
  });
  return (
    <div class="section bright">
      <div>{dadJokeSignal.value.joke}</div>
      <Form action={favoriteJokeAction}>
        <input type="hidden" name="jokeID" value={dadJokeSignal.value.id} />
        <button name="vote" value="up">
          üëç
        </button>
        <button name="vote" value="down">
          üëé
        </button>
      </Form>
      <button
        onClick$={() => (isFavoriteSignal.value = !isFavoriteSignal.value)}
      >
        {isFavoriteSignal.value ? '‚ù§Ô∏è' : 'ü§ç'}
      </button>
    </div>
  );
});
```
</CodeSandbox>

## 5. Tasks and Invoking Server Code

In Qwik, a [task](/docs/components/tasks/#usetask) is work that needs to happen when a state changes. (Similar to an "effect" in other frameworks.) In this example, we will use the task to invoke code on the server.

1. Create a new task that tracks the `isFavoriteSignal` state:
   ```tsx
   useTask$(({ track }) => {});
   ```
2. Add a `track` call to the re-executed the task on `isFavoriteSignal` state change:
   ```tsx
   useTask$(({ track }) => {
     track(()=> isFavoriteSignal.value);
   });
   ```
3. Add the work that you want to execute on state change:
   ```tsx
   useTask$(({ track }) => {
     track(()=> isFavoriteSignal.value);
     console.log('FAVORITE (isomorphic)', isFavoriteSignal.value);
   });
   ```
4. If you want to have work happen on the server only, wrap it in `server$()`
   ```tsx
   useTask$(({ track }) => {
     track(()=> isFavoriteSignal.value);
     console.log('FAVORITE (isomorphic)', isFavoriteSignal.value);
     server$(() => {
       console.log('FAVORITE (server)', isFavoriteSignal.value);
     })();
   });
   ```

NOTE:

- Notice that the body of `useTask$` is executed on both the server and the client (isomorphic).
- On SSR server prints `FAVORITE (isomorphic) false` and `FAVORITE (server) false`.
- When the user interacts with favorite, the client prints `FAVORITE (isomorphic) true` and the server prints `FAVORITE (server) true`.

<CodeSandbox src="/src/routes/demo/getting-started/05-tasks/index.tsx" style={{ height: '10em' }}>
```tsx
/* eslint-disable no-console */
import { component$, useSignal, useTask$ } from '@builder.io/qwik';
import {
  routeLoader$,
  Form,
  routeAction$,
  server$,
} from '@builder.io/qwik-city';

export const useDadJoke = routeLoader$(async () => {
  const response = await fetch('https://icanhazdadjoke.com/', {
    headers: { Accept: 'application/json' },
  });
  return (await response.json()) as {
    id: string;
    status: number;
    joke: string;
  };
});

export const useJokeVoteAction = routeAction$((props) => {
  console.log('VOTE', props);
});

export default component$(() => {
  const isFavoriteSignal = useSignal(false);
  const dadJokeSignal = useDadJoke();
  const favoriteJokeAction = useJokeVoteAction();
  useTask$(({ track }) => {
    track(()=> isFavoriteSignal.value);
    console.log('FAVORITE (isomorphic)', isFavoriteSignal.value);
    server$(() => {
      console.log('FAVORITE (server)', isFavoriteSignal.value);
    })();
  });
  return (
    <div class="section bright">
      <div>{dadJokeSignal.value.joke}</div>
      <Form action={favoriteJokeAction}>
        <input type="hidden" name="jokeID" value={dadJokeSignal.value.id} />
        <button name="vote" value="up">
          üëç
        </button>
        <button name="vote" value="down">
          üëé
        </button>
      </Form>
      <button
        onClick$={() => (isFavoriteSignal.value = !isFavoriteSignal.value)}
      >
        {isFavoriteSignal.value ? '‚ù§Ô∏è' : 'ü§ç'}
      </button>
    </div>
  );
});
```
</CodeSandbox>

## 6. Styling

Styling is an important part of any application. Qwik provides a way to associate and scope styles with your component.

To add styles:

1. Create a new file `src/routes/joke/index.css`:

   ```css
   div {
     font-weight: bold;
   }

   form {
     float: right;
   }
   ```

2. import the styles in `src/routes/joke/index.tsx`:
```tsx
import STYLES from "./index.css?inline";
``

   `
3. Tell the component to load the styles:
   ```tsx
   useStylesScoped$(STYLES);
   ```

NOTE:

- The `?inline` query parameter tells Vite to inline the styles into the component.
- The `useStylesScoped$` call tells Qwik to associate the styles with the component only (scoping).
- Styles are only loaded if they are not already inlined as part of SSR and only for the first component.

<CodeSandbox src="/src/routes/demo/getting-started/06-styling/index.tsx" style={{ height: '10em' }}>
```tsx
/* eslint-disable no-console */
import {
  component$,
  useSignal,
  useStylesScoped$,
  useTask$,
} from '@builder.io/qwik';
import {
  routeLoader$,
  Form,
  routeAction$,
  server$,
} from '@builder.io/qwik-city';
import STYLES from './index.css?inline';

export const useDadJoke = routeLoader$(async () => {
  const response = await fetch('https://icanhazdadjoke.com/', {
    headers: { Accept: 'application/json' },
  });
  return (await response.json()) as {
    id: string;
    status: number;
    joke: string;
  };
});

const useJokeVoteAction = routeAction$((props) => {
  console.log('VOTE', props);
});

export default component$(() => {
  useStylesScoped$(STYLES);
  const isFavoriteSignal = useSignal(false);
  const dadJokeSignal = useDadJoke();
  const favoriteJokeAction = useJokeVoteAction();
  useTask$(({ track }) => {
    track(()=> isFavoriteSignal.value);
    console.log('FAVORITE (isomorphic)', isFavoriteSignal.value);
    server$(() => {
      console.log('FAVORITE (server)', isFavoriteSignal.value);
    })();
  });
  return (
    <div class="section bright">
      <div>{dadJokeSignal.value.joke}</div>
      <Form action={favoriteJokeAction}>
        <input type="hidden" name="jokeID" value={dadJokeSignal.value.id} />
        <button name="vote" value="up">
          üëç
        </button>
        <button name="vote" value="down">
          üëé
        </button>
      </Form>
      <button
        onClick$={() => (isFavoriteSignal.value = !isFavoriteSignal.value)}
      >
        {isFavoriteSignal.value ? '‚ù§Ô∏è' : 'ü§ç'}
      </button>
    </div>
  );
});
```
</CodeSandbox>

## 7. Preview

We build a very simple application that gave you an overview of key Qwik concepts and API. The application is running in dev mode, which uses hot-module-reloading (HMR) to continuously update the application while changing the code.

While in dev mode:

- Each file is loaded individually, which may cause waterfalls in the network tab.
- There is no speculative loading of bundles, so there may be a delay on the first interaction.

Let's create a production build to see how the application will be delivered to the user and how the above is fixed.

To create a preview build:

1. Run `npm run preview` to create a production build.

NOTE:

- Your application should have a production build now and be running on a different port.
- If you interact with the application now, the network tab of the dev tools should show that the bundles are instantly delivered from the [ServiceWorker cache](/docs/advanced/speculative-module-fetching/).

## Review

Congratulations! You have made it through getting started. This overview is intentionally short to get you familiarized with different parts of Qwik. We recommended that you deep dive into the above concepts to learn more. Here are some key takeaways:


- [Project structure](/docs/(qwikcity)/project-structure/index.mdx)
- [Directory-based](/docs/(qwikcity)/routing/index.mdx) routing
- [Component](/docs/(qwik)/components/overview/index.mdx)
- [Route loaders](/docs/(qwikcity)/route-loader/index.mdx)
- [Form actions](/docs/(qwikcity)/action/index.mdx) (and [zod validation](/docs/(qwikcity)/action/index.mdx#zod-validation))
- [State management](/docs/(qwik)/components/state/index.mdx)
- [Tasks](/docs/(qwik)/components/tasks/index.mdx#use-usetask-when-you-need-to)
- [ServiceWorker cache](/docs/(qwik)/advanced/index.mdxspeculative-module-fetching/)
